\section{\textbf{Haar Approximation of Fractional Differential Equations}}

In this section, we would first look at the theory of approximating fractional differential equations and then we would show the MATLAB implementation as well as output.
\subsection{Theory}

Consider the fractional differential equation with variable coefficients : \\
$\mathbf{D_*^\alpha u(t)+a(t)u(t)=f(t),u^{(i)}=0, i=0,1,...,m-1, 0 < m-1 < \alpha \leq m}$ \\
By approximating $D_*^\alpha u(t)$, we have \\
$\mathbf{D_*^\alpha u(t) \equiv D_*^\alpha u_k(t) = \sum_{i=0}^{k-1} c_i h_i(t) = c^T H_k(t)}$ \\
Therefore, u(t) can be expressed in terms of operational matrix of fractional integration of haar wavelets as \\ $u(t) \equiv u_k(t)=c^T P_{k\times k}^\alpha H_k(t)$, where \\
$P_{k\times k}^\alpha = H_{k\times k}F_\alpha H_{k\times k}^{-1},$ \\ $F_\alpha = \frac{1}{m^\alpha}\frac{1}{\Gamma(\alpha+2)} \begin{bmatrix}
1&\epsilon_1&\epsilon_2&...&\epsilon_{m-1}\\ 
0&1&\epsilon_1&...&\epsilon_{m-2}\\ 
0&0&1&...&\epsilon_{m-3}\\ 
 ...&...&...&...&... \\ 
0&0&0&...&1  
\end{bmatrix} ,$ \\ $\xi_k = (k+1)^{\alpha+1} -2k^{\alpha+1} + (k-1)^{\alpha+1} $. \\ Also,\\~\\$H_{k \times k} = [H_k(\frac{1}{2k}) H_k(\frac{3}{2k}) ... H_k(\frac{2k-1}{2k})]$, where \\~\\ $ H_k(t) = [h_0(t),h_1(t),...,h_{k-1}(t)]^T$

Here, $P_{k \times k}$ is Operational Matrix of fractional integration of Haar wavelets.
\\~\\By Substituting these approximations in original equation, we get

$c^TH(t) + a(t) . c^T P_{k \times k}^\alpha H_k(t) = f(t)$
where $H=[H_k(t_0) H_k(t_1) ... H_k(t_{k-1})]$. \\~\\
This is a system of algebraic equations which can be solved easily using MATLAB.
\newpage
 \subsection{Implementation}
 In this section, we would show all the code listings necessary to implement the single equation solver.\\
 The Following code tries to find out the numerical solution of the differential equation
 \begin{equation*}
 D_*^{\frac{1}{3}}u(t)+t^{1/3}u(t)=\frac{3}{\Gamma{(\frac{2}{3})}}t^{\frac{2}{3}}+t^{\frac{4}{3}} , u(0)=0
 \end{equation*}
 1. differential\_solver.m\\
 {\fontfamily{pcr}\selectfont \lstinputlisting[language=Octave]{differential_solver.m}}
 
 \newpage
 2. return\_a\_matrix.m \\
  {\fontfamily{pcr}\selectfont \lstinputlisting[language=Octave]{return_a_matrix.m}}
  
  3. return\_fvalue\_vector.m
   {\fontfamily{pcr}\selectfont \lstinputlisting[language=Octave]{return_fvalue_vector.m}}
 
 4. return\_operational\_matrix.m
  {\fontfamily{pcr}\selectfont \footnotesize{\lstinputlisting[language=Octave]{return_operational_matrix.m}}}
 
 \newpage
 
 5.return\_p\_matrix.m
  {\fontfamily{pcr}\selectfont \footnotesize{\lstinputlisting[language=Octave]{return_p_matrix.m}}}
  
  6. return\_h\_column.m
   {\fontfamily{pcr}\selectfont \footnotesize{\lstinputlisting[language=Octave]{return_h_column.m}}}
   
 7.generate\_j\_k.m
  {\fontfamily{pcr}\selectfont \footnotesize{\lstinputlisting[language=Octave]{generate_j_k.m}}}
\newpage

8. return\_f\_matrix.m
 {\fontfamily{pcr}\selectfont \footnotesize{\lstinputlisting[language=Octave]{return_f_matrix.m}}}
 
 The output is as shown below in comparison with the exact solution $u(t)=t$.
 \\
 \begin{figure}[h]

\centering

    \includegraphics[scale=0.7]{lalu9.eps}

    \caption{Plot of the solution}

\end{figure} 

\newpage
We can extend this idea to solve system of equations as well, and the following code solves the given system of equations

$D_*^{\alpha1}u_1(t) = 2u_2^2(t), 0 < \alpha1\leq 1$ \\
$D_*^{\alpha2}u_2(t) = tu_1(t), 0 < \alpha2 \leq 1$ \\
$D_*^{\alpha3}u_3(t) = u_2(t)u_3(t), 0<\alpha3 \leq 1$ \\
with the initial conditions $u_1(0)=0, u_2(0)=1,u_3(0)=1$.\\~\\

system\_solver.m

 {\fontfamily{pcr}\selectfont \footnotesize{\lstinputlisting{system_solver.m}}}
 \\~\\
 
 Figure 4,5,6 shows the plot of the solution for k=2. 
 
 \begin{figure}

\centering

    \includegraphics[scale=0.4]{u1.eps}

    \caption{Plot of the solution: u1}
     \includegraphics[scale=0.4]{u2.eps}

    \caption{Plot of the solution: u2}

 \includegraphics[scale=0.4]{u3.eps}

    \caption{Plot of the solution: u3}

\end{figure} 


 
 
 
 
 